# -*- coding: utf-8 -*-
# DirtyFindCrypto.py
#
# Fast crypto constant finder for Ghidra
# @author J. DeFrancesco
# @category MSP430

EXPORT_CSV = False
CSV_FILENAME = "DirtyFindCrypto_hits.csv"
COMMENT_PREFIX = "[Dirty430 CryptoFinder]"
LABEL_FORCE_PRIMARY = True

try:
    from ghidra.program.model.mem import MemoryAccessException
    from ghidra.program.model.data import ByteDataType, DWordDataType, ArrayDataType
    from ghidra.util.task import TaskMonitor
    from ghidra.program.flatapi import FlatProgramAPI
    import jarray
except:
    print("Warning: Ghidra imports failed. This script must run in Ghidra.")
    pass

def bytes_from_list_u8(lst):
    return bytearray([x & 0xff for x in lst])

def u32_le_bytes(v):
    v = v & 0xffffffff
    return bytearray([v & 0xff, (v >> 8) & 0xff, (v >> 16) & 0xff, (v >> 24) & 0xff])

def dwords_to_le_bytes(dlist):
    out = bytearray()
    for v in dlist:
        out.extend(u32_le_bytes(v))
    return out

def fmt_addr(addr):
    try:
        return str(addr)
    except:
        return "<addr>"

def define_array_at(addr, total_len_bytes, dtype):
    try:
        elem_len = dtype.getLength()
        if elem_len <= 0:
            return False
        count = max(1, total_len_bytes // elem_len)
        arr = ArrayDataType(dtype, count, elem_len)
        createData(addr, arr)
        return True
    except:
        return False

def add_crypto_bookmark(addr, short_text, long_text=None):
    try:
        createBookmark(addr, "Info", "CRYPTO", short_text)
    except:
        pass
    try:
        if long_text:
            setPlateComment(addr, long_text)
        else:
            setPlateComment(addr, short_text)
    except:
        pass

def make_label(addr, label):
    try:
        createLabel(addr, label, LABEL_FORCE_PRIMARY)
    except:
        try:
            createLabel(addr, label, False)
        except:
            pass

class CryptoFinder(object):
    def __init__(self, program):
        self.prog = program
        self.api = FlatProgramAPI(program)
        self.mem = program.getMemory()
        self.minA = self.mem.getMinAddress()
        self.maxA = self.mem.getMaxAddress()
        self.report = []

    def _to_java_bytes(self, py_bytes):
        if isinstance(py_bytes, basestring):
            seq = [ord(c) & 0xff for c in py_bytes]
        else:
            seq = [int(x) & 0xff for x in py_bytes]
        signed = [b if b < 0x80 else b - 0x100 for b in seq]
        return jarray.array(signed, 'b')

    def _find_all(self, seq_bytes):
        pattern = self._to_java_bytes(seq_bytes)
        start = self.minA
        while True:
            hit = self.mem.findBytes(start, self.maxA, pattern, None, True, TaskMonitor.DUMMY)
            if hit is None:
                break
            yield hit
            try:
                start = hit.add(1)
            except:
                break

    def scan_and_label(self, seq_bytes, label_prefix, dtype, define_len=None, describe=None):
        hits = 0
        tlen = define_len if define_len is not None else len(seq_bytes)
        i = 0
        for addr in self._find_all(seq_bytes):
            label = "%s_%d" % (label_prefix, i)
            make_label(addr, label)
            define_array_at(addr, tlen, dtype)
            short = "%s %s @ %s" % (COMMENT_PREFIX, label_prefix, fmt_addr(addr))
            long = "%s found %s\nlen=%d bytes" % (COMMENT_PREFIX, label_prefix, tlen)
            if describe:
                long += "\n" + describe
            add_crypto_bookmark(addr, short, long)
            self.report.append((label, addr))
            hits += 1
            i += 1
        return hits

    def find_large_blocks(self, min_size):
        blocks = []
        addr = self.minA
        in_block = False
        block_start = None
        block_len = 0
        while addr and addr <= self.maxA:
            try:
                self.mem.getByte(addr)
                readable = True
            except MemoryAccessException:
                readable = False
            if not readable:
                if in_block and block_len >= min_size:
                    blocks.append((block_start, block_len))
                in_block = False
                block_start = None
                block_len = 0
            else:
                if not in_block:
                    in_block = True
                    block_start = addr
                    block_len = 1
                else:
                    block_len += 1
            if addr.equals(self.maxA):
                if in_block and block_len >= min_size:
                    blocks.append((block_start, block_len))
                break
            addr = addr.next()
        return blocks

def main():
    print("=== [D430 CryptoFinder] ===")
    cf = CryptoFinder(currentProgram)


    AES_SBOX = [
        0x63,0x7c,0x77,0x7b,0xf2,0x6b,0x6f,0xc5,0x30,0x01,0x67,0x2b,0xfe,0xd7,0xab,0x76,
        0xca,0x82,0xc9,0x7d,0xfa,0x59,0x47,0xf0,0xad,0xd4,0xa2,0xaf,0x9c,0xa4,0x72,0xc0,
        0xb7,0xfd,0x93,0x26,0x36,0x3f,0xf7,0xcc,0x34,0xa5,0xe5,0xf1,0x71,0xd8,0x31,0x15,
        0x04,0xc7,0x23,0xc3,0x18,0x96,0x05,0x9a,0x07,0x12,0x80,0xe2,0xeb,0x27,0xb2,0x75,
        0x09,0x83,0x2c,0x1a,0x1b,0x6e,0x5a,0xa0,0x52,0x3b,0xd6,0xb3,0x29,0xe3,0x2f,0x84,
        0x53,0xd1,0x00,0xed,0x20,0xfc,0xb1,0x5b,0x6a,0xcb,0xbe,0x39,0x4a,0x4c,0x58,0xcf,
        0xd0,0xef,0xaa,0xfb,0x43,0x4d,0x33,0x85,0x45,0xf9,0x02,0x7f,0x50,0x3c,0x9f,0xa8,
        0x51,0xa3,0x40,0x8f,0x92,0x9d,0x38,0xf5,0xbc,0xb6,0xda,0x21,0x10,0xff,0xf3,0xd2,
        0xcd,0x0c,0x13,0xec,0x5f,0x97,0x44,0x17,0xc4,0xa7,0x7e,0x3d,0x64,0x5d,0x19,0x73,
        0x60,0x81,0x4f,0xdc,0x22,0x2a,0x90,0x88,0x46,0xee,0xb8,0x14,0xde,0x5e,0x0b,0xdb,
        0xe0,0x32,0x3a,0x0a,0x49,0x06,0x24,0x5c,0xc2,0xd3,0xac,0x62,0x91,0x95,0xe4,0x79,
        0xe7,0xc8,0x37,0x6d,0x8d,0xd5,0x4e,0xa9,0x6c,0x56,0xf4,0xea,0x65,0x7a,0xae,0x08,
        0xba,0x78,0x25,0x2e,0x1c,0xa6,0xb4,0xc6,0xe8,0xdd,0x74,0x1f,0x4b,0xbd,0x8b,0x8a,
        0x70,0x3e,0xb5,0x66,0x48,0x03,0xf6,0x0e,0x61,0x35,0x57,0xb9,0x86,0xc1,0x1d,0x9e,
        0xe1,0xf8,0x98,0x11,0x69,0xd9,0x8e,0x94,0x9b,0x1e,0x87,0xe9,0xce,0x55,0x28,0xdf,
        0x8c,0xa1,0x89,0x0d,0xbf,0xe6,0x42,0x68,0x41,0x99,0x2d,0x0f,0xb0,0x54,0xbb,0x16
    ]

    AES_INV_SBOX = [
        0x52,0x09,0x6a,0xd5,0x30,0x36,0xa5,0x38,0xbf,0x40,0xa3,0x9e,0x81,0xf3,0xd7,0xfb,
        0x7c,0xe3,0x39,0x82,0x9b,0x2f,0xff,0x87,0x34,0x8e,0x43,0x44,0xc4,0xde,0xe9,0xcb,
        0x54,0x7b,0x94,0x32,0xa6,0xc2,0x23,0x3d,0xee,0x4c,0x95,0x0b,0x42,0xfa,0xc3,0x4e,
        0x08,0x2e,0xa1,0x66,0x28,0xd9,0x24,0xb2,0x76,0x5b,0xa2,0x49,0x6d,0x8b,0xd1,0x25,
        0x72,0xf8,0xf6,0x64,0x86,0x68,0x98,0x16,0xd4,0xa4,0x5c,0xcc,0x5d,0x65,0xb6,0x92,
        0x6c,0x70,0x48,0x50,0xfd,0xed,0xb9,0xda,0x5e,0x15,0x46,0x57,0xa7,0x8d,0x9d,0x84,
        0x90,0xd8,0xab,0x00,0x8c,0xbc,0xd3,0x0a,0xf7,0xe4,0x58,0x05,0xb8,0xb3,0x45,0x06,
        0xd0,0x2c,0x1e,0x8f,0xca,0x3f,0x0f,0x02,0xc1,0xaf,0xbd,0x03,0x01,0x13,0x8a,0x6b,
        0x3a,0x91,0x11,0x41,0x4f,0x67,0xdc,0xea,0x97,0xf2,0xcf,0xce,0xf0,0xb4,0xe6,0x73,
        0x96,0xac,0x74,0x22,0xe7,0xad,0x35,0x85,0xe2,0xf9,0x37,0xe8,0x1c,0x75,0xdf,0x6e,
        0x47,0xf1,0x1a,0x71,0x1d,0x29,0xc5,0x89,0x6f,0xb7,0x62,0x0e,0xaa,0x18,0xbe,0x1b,
        0xfc,0x56,0x3e,0x4b,0xc6,0xd2,0x79,0x20,0x9a,0xdb,0xc0,0xfe,0x78,0xcd,0x5a,0xf4,
        0x1f,0xdd,0xa8,0x33,0x88,0x07,0xc7,0x31,0xb1,0x12,0x10,0x59,0x27,0x80,0xec,0x5f,
        0x60,0x51,0x7f,0xa9,0x19,0xb5,0x4a,0x0d,0x2d,0xe5,0x7a,0x9f,0x93,0xc9,0x9c,0xef,
        0xa0,0xe0,0x3b,0x4d,0xae,0x2a,0xf5,0xb0,0xc8,0xeb,0xbb,0x3c,0x83,0x53,0x99,0x61,
        0x17,0x2b,0x04,0x7e,0xba,0x77,0xd6,0x26,0xe1,0x69,0x14,0x63,0x55,0x21,0x0c,0x7d
    ]

    AES_RCON = [0x01,0x02,0x04,0x08,0x10,0x20,0x40,0x80,0x1B,0x36]

    SHA1_H = [0x67452301,0xEFCDAB89,0x98BADCFE,0x10325476,0xC3D2E1F0]

    SHA256_K = [
        0x428A2F98,0x71374491,0xB5C0FBCF,0xE9B5DBA5,0x3956C25B,0x59F111F1,0x923F82A4,0xAB1C5ED5,
        0xD807AA98,0x12835B01,0x243185BE,0x550C7DC3,0x72BE5D74,0x80DEB1FE,0x9BDC06A7,0xC19BF174,
        0xE49B69C1,0xEFBE4786,0x0FC19DC6,0x240CA1CC,0x2DE92C6F,0x4A7484AA,0x5CB0A9DC,0x76F988DA,
        0x983E5152,0xA831C66D,0xB00327C8,0xBF597FC7,0xC6E00BF3,0xD5A79147,0x06CA6351,0x14292967,
        0x27B70A85,0x2E1B2138,0x4D2C6DFC,0x53380D13,0x650A7354,0x766A0ABB,0x81C2C92E,0x92722C85,
        0xA2BFE8A1,0xA81A664B,0xC24B8B70,0xC76C51A3,0xD192E819,0xD6990624,0xF40E3585,0x106AA070,
        0x19A4C116,0x1E376C08,0x2748774C,0x34B0BCB5,0x391C0CB3,0x4ED8AA4A,0x5B9CCA4F,0x682E6FF3,
        0x748F82EE,0x78A5636F,0x84C87814,0x8CC70208,0x90BEFFFA,0xA4506CEB,0xBEF9A3F7,0xC67178F2
    ]

    MD5_T = [
        0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,
        0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,0x6b901122,0xfd987193,0xa679438e,0x49b40821,
        0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,0xd62f105d,0x02441453,0xd8a1e681,0xe7d3fbc8,
        0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,
        0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,
        0x289b7ec6,0xeaa127fa,0xd4ef3085,0x04881d05,0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,
        0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,
        0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391
    ]

    BLOWP = [
        0x243F6A88,0x85A308D3,0x13198A2E,0x03707344,0xA4093822,0x299F31D0,0x082EFA98,0xEC4E6C89,
        0x452821E6,0x38D01377,0xBE5466CF,0x34E90C6C,0xC0AC29B7,0xC97C50DD,0x3F84D5B5,0xB5470917,
        0x9216D5D9,0x8979FB1B
    ]

    TEA_DELTA = u32_le_bytes(0x9E3779B9)

    AES_SBOX_B     = bytes_from_list_u8(AES_SBOX)
    AES_INV_SBOX_B = bytes_from_list_u8(AES_INV_SBOX)
    AES_RCON_B     = bytes_from_list_u8(AES_RCON)
    SHA1_H_B       = dwords_to_le_bytes(SHA1_H)
    SHA256_K_B     = dwords_to_le_bytes(SHA256_K)
    MD5_T_B        = dwords_to_le_bytes(MD5_T)
    BLOWP_B        = dwords_to_le_bytes(BLOWP)

    hits  = cf.scan_and_label(AES_SBOX_B,     "CRYPTO_AES_SBOX",     ByteDataType(),  len(AES_SBOX_B),     "AES S-box (256 bytes)")
    hits += cf.scan_and_label(AES_INV_SBOX_B, "CRYPTO_AES_INV_SBOX", ByteDataType(),  len(AES_INV_SBOX_B), "AES inverse S-box (256 bytes)")
    hits += cf.scan_and_label(AES_RCON_B,     "CRYPTO_AES_RCON",     ByteDataType(),  len(AES_RCON),       "AES Rcon (10 bytes)")
    hits += cf.scan_and_label(SHA1_H_B,       "CRYPTO_SHA1_H",       DWordDataType(), len(SHA1_H)*4,       "SHA-1 IV (5 words)")
    hits += cf.scan_and_label(SHA256_K_B,     "CRYPTO_SHA256_K",     DWordDataType(), len(SHA256_K)*4,     "SHA-256 round constants (64 words)")
    hits += cf.scan_and_label(MD5_T_B,        "CRYPTO_MD5_T",        DWordDataType(), len(MD5_T)*4,        "MD5 T constants (64 words)")
    hits += cf.scan_and_label(BLOWP_B,        "CRYPTO_BLOWFISH_P",   DWordDataType(), len(BLOWP)*4,        "Blowfish P-array (18 words)")

    tea_hits = list(cf._find_all(TEA_DELTA))
    for i, a in enumerate(tea_hits):
        lbl = "CRYPTO_TEA_DELTA_%d" % i
        make_label(a, lbl)
        define_array_at(a, 4, DWordDataType())
        add_crypto_bookmark(a, COMMENT_PREFIX + " TEA_DELTA", "TEA delta constant")
        cf.report.append((lbl, a))

    # Optional heuristic: scan large contiguous readable blocks (unchanged)
    # blocks = cf.find_large_blocks(176)
    # for i,(addr,size) in enumerate(blocks):
    #     if size >= 1024:
    #         lbl = "POTENTIAL_AES_TABLE_%d_%dB" % (i,size)
    #         make_label(addr,lbl)
    #         define_array_at(addr, min(size,4096), ByteDataType())
    #         cf.report.append((lbl,addr))
    #     else:
    #         lbl = "CRYPTO_LARGE_BLOCK_%d_%dB" % (i,size)
    #         make_label(addr,lbl)
    #         define_array_at(addr, min(size,1024), ByteDataType())
    #         cf.report.append((lbl,addr))

    print("\n Crypto Results:\n")
    rep_count = 0
    for lbl, addr in cf.report:
        print("  %-35s @ %s" % (lbl, fmt_addr(addr)))
        rep_count += 1
    print("Total labels: %d" % rep_count)
    print("===== END CRYPTO FINDER ======")

if __name__ == "__main__":
    main()
